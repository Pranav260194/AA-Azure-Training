{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "td-aa-trng-adf"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/dataflow7')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "rim_copy",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "test1",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "GenericReason"
						}
					],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> source1\nsource1 derive(GenericReason = locate(NoSalesReason, 'Other')) ~> GenericReason\nGenericReason sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow8')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DelimitedText35",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DelimitedText35",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          empid as string,",
						"          emname as string,",
						"          empsal as string,",
						"          comp as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 derive(column1 = locate(comp, 'cts')) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          empid as string,",
						"          emname as string,",
						"          empsal as string,",
						"          comp as string",
						"     ),",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow9')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "abc1",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "abc2",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Flight#} as string,",
						"          Origin as string,",
						"          Dest as string,",
						"          FlightDate as string,",
						"          NoSalesReason as string,",
						"          TransmittingFlightAttd as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 derive(newupdate = locate(NoSalesReason, 'Other')) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dc186053_TransformMovies')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "moviesDB",
								"type": "DatasetReference"
							},
							"name": "moviesDB"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "dc186053_MoviesSink",
								"type": "DatasetReference"
							},
							"name": "MoviesSink"
						}
					],
					"transformations": [
						{
							"name": "FilterYears"
						},
						{
							"name": "AggregateComedyRating"
						}
					],
					"script": "source(output(\n\t\tmovie as string,\n\t\ttitle as string,\n\t\tgenres as string,\n\t\tyear as string,\n\t\tRating as string,\n\t\t{Rotton Tomato} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tpartitionBy('hash', 1)) ~> moviesDB\nmoviesDB filter(toInteger(year) >= 1910 && toInteger(year) <= 2000 && rlike(genres, 'Comedy'),\n\tpartitionBy('hash', 1)) ~> FilterYears\nFilterYears aggregate(groupBy(year),\n\tAverageComedyRating = avg(toInteger(Rating)),\n\tpartitionBy('hash', 1)) ~> AggregateComedyRating\nAggregateComedyRating sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> MoviesSink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_Third_Lowest_Sal')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_td255024_salary_csv",
								"type": "DatasetReference"
							},
							"name": "SrcEmployeeSalary"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_td255024_output_csv",
								"type": "DatasetReference"
							},
							"name": "sink"
						}
					],
					"transformations": [
						{
							"name": "Sort"
						},
						{
							"name": "Window"
						},
						{
							"name": "Filter"
						}
					],
					"script": "source(output(\n\t\tname as string,\n\t\tsalary as string,\n\t\t{department } as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> SrcEmployeeSalary\nSrcEmployeeSalary sort(asc({department }, true),\n\tcaseInsensitive: true) ~> Sort\nSort window(over({department }),\n\tasc(salary, true),\n\tRNK = denseRank()) ~> Window\nWindow filter(RNK == 3) ~> Filter\nFilter sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tname,\n\t\tsalary,\n\t\t{department }\n\t)) ~> sink"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_dup_split')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_td255024_csv",
								"type": "DatasetReference"
							},
							"name": "SrcDuplicateFile"
						},
						{
							"dataset": {
								"referenceName": "ds_td255024_csv",
								"type": "DatasetReference"
							},
							"name": "SrcDuplicateFile2"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_td255024_out_csv",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"dataset": {
								"referenceName": "ds_td255024_out_csv",
								"type": "DatasetReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "Aggregator"
						},
						{
							"name": "Joiner"
						},
						{
							"name": "SelectTransformation"
						},
						{
							"name": "ConditionalSplit"
						}
					],
					"script": "source(output(\n\t\tCol1 as string,\n\t\tCol2 as string,\n\t\tCol3 as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> SrcDuplicateFile\nsource(output(\n\t\tCol1 as string,\n\t\tCol2 as string,\n\t\tCol3 as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> SrcDuplicateFile2\nSrcDuplicateFile aggregate(groupBy(Col1,\n\t\tCol2,\n\t\tCol3),\n\tAgg_Col = count(Col1)) ~> Aggregator\nAggregator, SrcDuplicateFile2 join(Aggregator@Col1 == SrcDuplicateFile2@Col1,\n\tjoinType:'right',\n\tmatchType:'exact',\n\tignoreSpaces: false,\n\tbroadcast: 'auto')~> Joiner\nJoiner select(mapColumn(\n\t\tCol1 = Aggregator@Col1,\n\t\tCol2 = Aggregator@Col2,\n\t\tCol3 = Aggregator@Col3,\n\t\tAgg_Col,\n\t\tCol1 = SrcDuplicateFile2@Col1,\n\t\tCol2 = SrcDuplicateFile2@Col2,\n\t\tCol3 = SrcDuplicateFile2@Col3\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectTransformation\nSelectTransformation split(Agg_Col == 1,\n\tdisjoint: false) ~> ConditionalSplit@(NonDups, Dups)\nConditionalSplit@NonDups sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink1\nConditionalSplit@Dups sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_dup_split_keep_orig_rec')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ds_td255024_csv",
								"type": "DatasetReference"
							},
							"name": "SrcDuplicateFile"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ds_td255024_out_csv",
								"type": "DatasetReference"
							},
							"name": "sink1"
						},
						{
							"dataset": {
								"referenceName": "ds_td255024_out_csv",
								"type": "DatasetReference"
							},
							"name": "sink2"
						}
					],
					"transformations": [
						{
							"name": "ConditionalSplit"
						},
						{
							"name": "Sort"
						},
						{
							"name": "Window"
						}
					],
					"script": "source(output(\n\t\tCol1 as string,\n\t\tCol2 as string,\n\t\tCol3 as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> SrcDuplicateFile\nWindow split(ROW_NUM == 1,\n\tdisjoint: false) ~> ConditionalSplit@(NonDups, Dups)\nSrcDuplicateFile sort(asc(Col1, true),\n\tcaseInsensitive: true) ~> Sort\nSort window(over(Col1),\n\tasc(Col1, true),\n\tROW_NUM = rowNumber()) ~> Window\nConditionalSplit@NonDups sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink1\nConditionalSplit@Dups sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink2"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_v2')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "dc186053_v2_source",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DelimitedText1",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "DerivedColumn1"
						}
					],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> source1\nsource1 derive(NotAcceptableReason = locate(NoSalesReason, 'Other')) ~> DerivedColumn1\nDerivedColumn1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/hg250013_makeDataPartitioned')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "ADF_Demo_DF"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "hg250013_flat_file_source_ds",
								"type": "DatasetReference"
							},
							"name": "FlatSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "hg250013_csv_partitioned_ds",
								"type": "DatasetReference"
							},
							"name": "sink4"
						}
					],
					"transformations": [],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\twildcardPaths:['input/*']) ~> FlatSource\nFlatSource sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('key',\n\t\t0,\n\t\tFlightDate\n\t)) ~> sink4"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/is255014_xfm_1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "input_testFile",
								"type": "DatasetReference"
							},
							"name": "RIMsource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "output_testFile",
								"type": "DatasetReference"
							},
							"name": "dataflowoutput"
						}
					],
					"transformations": [
						{
							"name": "GenericReason"
						}
					],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> RIMsource\nRIMsource derive(GenericReason = locate(NoSalesReason,'Other')) ~> GenericReason\nGenericReason sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\t{Flight#^Origin^Dest^FlightDate^NoSalesReason^TransmittingFlightAttd^addedcol} as string\n\t),\n\tpartitionFileNames:['RIM'],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> dataflowoutput"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ku255007Data flow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "kufinal",
								"type": "DatasetReference"
							},
							"name": "RIMSourceData"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ku255007output",
								"type": "DatasetReference"
							},
							"name": "Outputdata"
						}
					],
					"transformations": [
						{
							"name": "Flag"
						}
					],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> RIMSourceData\nRIMSourceData derive(Flag = locate(NoSalesReason,'Other')) ~> Flag\nFlag sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string,\n\t\t{Flag for No sales } as string\n\t),\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Outputdata"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ku255007adfrimdata')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ku255007source",
								"type": "DatasetReference"
							},
							"name": "sourcerim"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ku255007output",
								"type": "DatasetReference"
							},
							"name": "sinkoutputdata"
						}
					],
					"transformations": [
						{
							"name": "Flag"
						}
					],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> sourcerim\nsourcerim derive(Flagfornosales = locate(NoSalesReason,'Other')) ~> Flag\nFlag sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string,\n\t\t{Flag for No sales } as string\n\t),\n\tpartitionFileNames:['output_rim_dataflow.csv'],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\t{Flight#},\n\t\tOrigin,\n\t\tDest,\n\t\tFlightDate,\n\t\tNoSalesReason,\n\t\tTransmittingFlightAttd,\n\t\t{Flag for No sales } = Flagfornosales\n\t),\n\tpartitionBy('hash', 1)) ~> sinkoutputdata"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/mb255079_RIM_dataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "mb255079_src_customer",
								"type": "DatasetReference"
							},
							"name": "customer"
						},
						{
							"dataset": {
								"referenceName": "mb255079_src_sales",
								"type": "DatasetReference"
							},
							"name": "Sales"
						},
						{
							"dataset": {
								"referenceName": "mb255079_statelist",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "mb255079rimoutput",
								"type": "DatasetReference"
							},
							"name": "OutputDS",
							"rejectedDataLinkedService": {
								"referenceName": "adls_ls",
								"type": "LinkedServiceReference"
							}
						}
					],
					"transformations": [
						{
							"name": "selectcust1"
						},
						{
							"name": "windowRowNum"
						},
						{
							"name": "filterDistinct"
						},
						{
							"name": "DataCleaning"
						},
						{
							"name": "selectSales1"
						},
						{
							"name": "window1"
						},
						{
							"name": "UniqueOrderID"
						},
						{
							"name": "selectNonDupes"
						},
						{
							"name": "aggregate1"
						},
						{
							"name": "castSales"
						},
						{
							"name": "castCustomer"
						},
						{
							"name": "quantityless10"
						},
						{
							"name": "orderfilter"
						},
						{
							"name": "derivedColumn2"
						},
						{
							"name": "cast1"
						},
						{
							"name": "select1"
						},
						{
							"name": "Stateabb"
						},
						{
							"name": "join1"
						},
						{
							"name": "aggregateCustomerID"
						},
						{
							"name": "joinCustSales"
						},
						{
							"name": "RemoveExtras"
						}
					],
					"scriptLines": [
						"source(output(",
						"          CustomerID as string,",
						"          FirstName as string,",
						"          LastName as string,",
						"          Email as string,",
						"          Address as string,",
						"          City as string,",
						"          Country as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> customer",
						"source(output(",
						"          OrderID as string,",
						"          CustomerID as string,",
						"          ProductID as string,",
						"          Quantity as string,",
						"          Price as string,",
						"          OrderDate as string,",
						"          Region as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> Sales",
						"source(output(",
						"          State as string,",
						"          {abbreviations } as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"customer select(mapColumn(",
						"          CustomerID,",
						"          FirstName,",
						"          LastName,",
						"          Email,",
						"          Address,",
						"          City,",
						"          Country",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectcust1",
						"castCustomer window(over(CustomerID,",
						"          FirstName,",
						"          LastName,",
						"          Email,",
						"          Address,",
						"          City,",
						"          Country),",
						"     asc(CustomerID, true),",
						"     rownum = rowNumber()) ~> windowRowNum",
						"windowRowNum filter(rownum==1) ~> filterDistinct",
						"filterDistinct derive(FirstName = initCap(lower(FirstName)),",
						"          LastName = initCap(lower(LastName)),",
						"          Email = trim(Email),",
						"          FullName = initCap(lower(FirstName))+\" \"+initCap(lower(LastName)),",
						"          Address = replace(Address,'$','')) ~> DataCleaning",
						"Sales select(mapColumn(",
						"          OrderID,",
						"          CustomerID,",
						"          ProductID,",
						"          Quantity,",
						"          Price,",
						"          OrderDate,",
						"          Region",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectSales1",
						"castSales window(over(OrderID,",
						"          CustomerID),",
						"     asc(CustomerID, true),",
						"     rownum = rowNumber()) ~> window1",
						"window1 filter(rownum==1) ~> UniqueOrderID",
						"UniqueOrderID select(mapColumn(",
						"          OrderID,",
						"          CustomerID,",
						"          ProductID,",
						"          Quantity,",
						"          Price,",
						"          OrderDate,",
						"          Region",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> selectNonDupes",
						"selectNonDupes aggregate(groupBy(ProductID,",
						"          Region),",
						"     TotalQuantity = sum(Quantity),",
						"          TotalPrice = sum(Price),",
						"          avg_sales_price = sum(Price)/sum(Quantity)) ~> aggregate1",
						"selectSales1 cast(output(",
						"          OrderID as integer,",
						"          CustomerID as integer,",
						"          ProductID as integer,",
						"          Quantity as integer,",
						"          Price as float,",
						"          OrderDate as string,",
						"          Region as string",
						"     ),",
						"     errors: true) ~> castSales",
						"selectcust1 cast(output(",
						"          CustomerID as integer,",
						"          FirstName as string,",
						"          LastName as string,",
						"          Email as string,",
						"          Address as string,",
						"          City as string,",
						"          Country as string",
						"     ),",
						"     errors: true) ~> castCustomer",
						"aggregate1 filter(TotalQuantity<10) ~> quantityless10",
						"quantityless10 filter(TotalPrice>10.0) ~> orderfilter",
						"cast1 derive(difference = round((currentTimestamp()-OrderDate)/86400000),",
						"          year = year(OrderDate)) ~> derivedColumn2",
						"selectNonDupes cast(output(",
						"          OrderDate as timestamp 'MM/dd/yyyy'",
						"     ),",
						"     errors: true) ~> cast1",
						"DataCleaning select(mapColumn(",
						"          CustomerID,",
						"          FirstName,",
						"          LastName,",
						"          Email,",
						"          Address,",
						"          City,",
						"          Country,",
						"          FullName",
						"     ),",
						"     skipDuplicateMapInputs: false,",
						"     skipDuplicateMapOutputs: false) ~> select1",
						"derivedColumn2, source1 lookup(Region == State,",
						"     multiple: false,",
						"     pickup: 'any',",
						"     broadcast: 'auto')~> Stateabb",
						"select1, Stateabb join(select1@CustomerID == selectNonDupes@CustomerID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> join1",
						"join1 aggregate(groupBy(Customerid = select1@CustomerID),",
						"     TotalQuantity = sum(Quantity),",
						"          TotalPrice = sum(Price)) ~> aggregateCustomerID",
						"aggregateCustomerID, join1 join(aggregateCustomerID@Customerid == select1@CustomerID,",
						"     joinType:'inner',",
						"     matchType:'exact',",
						"     ignoreSpaces: false,",
						"     broadcast: 'auto')~> joinCustSales",
						"joinCustSales select(mapColumn(",
						"          Customerid = aggregateCustomerID@Customerid,",
						"          FullName,",
						"          TotalQuantity,",
						"          TotalPrice,",
						"          Email,",
						"          Address,",
						"          City,",
						"          Country,",
						"          OrderID,",
						"          ProductID,",
						"          Quantity,",
						"          Price,",
						"          OrderDate,",
						"          Region,",
						"          difference,",
						"          year,",
						"          {abbreviations }",
						"     ),",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> RemoveExtras",
						"RemoveExtras sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['mb255079rimoutput'],",
						"     umask: 0000,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     partitionBy('hash', 1)) ~> OutputDS"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/mm255199_rim_hist_aggr')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "mm255199_rim_input",
								"type": "DatasetReference"
							},
							"name": "Riminput"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "mm255199_Rim_Output",
								"type": "DatasetReference"
							},
							"name": "mm255199rimoutput"
						}
					],
					"transformations": [
						{
							"name": "GenericReason"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Flight#} as string,",
						"          Origin as string,",
						"          Dest as string,",
						"          FlightDate as string,",
						"          NoSalesReason as string,",
						"          TransmittingFlightAttd as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> Riminput",
						"Riminput derive(GenericReason = locate(NoSalesReason,'Other')) ~> GenericReason",
						"GenericReason sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> mm255199rimoutput"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/npdataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "Source_File",
								"type": "DatasetReference"
							},
							"name": "InputFile"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "generic_reason_new_col",
								"type": "DatasetReference"
							},
							"name": "genericreason"
						}
					],
					"transformations": [
						{
							"name": "ReasonGeneric",
							"description": "derived column"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Flight#} as string,",
						"          Origin as string,",
						"          Dest as string,",
						"          FlightDate as string,",
						"          NoSalesReason as string,",
						"          TransmittingFlightAttd as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> InputFile",
						"InputFile derive({No_Sales_Generic_Reason } = locate(NoSalesReason,'Other')) ~> ReasonGeneric",
						"ReasonGeneric sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> genericreason"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/nt255028_usecase_demo')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "usecase_demo_dataset_ip",
								"type": "DatasetReference"
							},
							"name": "EmpSource"
						},
						{
							"dataset": {
								"referenceName": "usecase_demo_dataset2",
								"type": "DatasetReference"
							},
							"name": "EmpNewSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "usecase_Demo_op",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "Union1"
						},
						{
							"name": "RemoveDuplicates"
						},
						{
							"name": "Sort1"
						}
					],
					"script": "source(output(\n\t\tEmp_ID as string,\n\t\tEmp_Name as string,\n\t\tCountry as string,\n\t\tDept_No as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpSource\nsource(output(\n\t\tEmp_ID as string,\n\t\tEmp_Name as string,\n\t\tCountry as string,\n\t\tDept_No as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> EmpNewSource\nEmpSource, EmpNewSource union(byName: true)~> Union1\nUnion1 aggregate(groupBy(Emp_ID),\n\teach(match(name!=\"Emp_ID\"), $$ = first($$))) ~> RemoveDuplicates\nRemoveDuplicates sort(asc(Emp_ID, true)) ~> Sort1\nSort1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:['usecase_demo_result.csv'],\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tpartitionBy('hash', 1)) ~> sink1"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/nt255028dataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "nt255028_dataset",
								"type": "DatasetReference"
							},
							"name": "Source"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "nt255028dataset",
								"type": "DatasetReference"
							},
							"name": "outputrim"
						}
					],
					"transformations": [
						{
							"name": "NewCol"
						}
					],
					"script": "source(output(\n\t\t{Flight#} as string,\n\t\tOrigin as string,\n\t\tDest as string,\n\t\tFlightDate as string,\n\t\tNoSalesReason as string,\n\t\tTransmittingFlightAttd as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> Source\nSource derive(NewCol = locate(NoSalesReason, 'Other')) ~> NewCol\nNewCol sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tumask: 0022,\n\tpreCommands: [],\n\tpostCommands: [],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> outputrim"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pb255086_data_flow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "PB255086_demo_dataset",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "PB255086_demo_dataset",
								"type": "DatasetReference"
							},
							"name": "sink1"
						}
					],
					"transformations": [
						{
							"name": "derivedColumn1"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Flight#} as string,",
						"          Origin as string,",
						"          Dest as string,",
						"          FlightDate as string,",
						"          NoSalesReason as string,",
						"          TransmittingFlightAttd as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 derive(tag = locate(NoSalesReason,'Other')) ~> derivedColumn1",
						"derivedColumn1 sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     input(",
						"          FlightNo as string,",
						"          Origin as string,",
						"          Dest as string,",
						"          FlightDate as string,",
						"          NoSalesReason as string,",
						"          {TransmittingFlightAttd,,,,,} as string",
						"     ),",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> sink1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ru255006_dataflow')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ru255006_src_data",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ru255006_New_tgt_data",
								"type": "DatasetReference"
							},
							"name": "output1"
						}
					],
					"transformations": [
						{
							"name": "SalChk"
						}
					],
					"scriptLines": [
						"source(output(",
						"          NAME as string,",
						"          DEPARTMENT as string,",
						"          DESIGNATION as string,",
						"          SALARY as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 derive(Valid_Sal = locate(SALARY, '500')) ~> SalChk",
						"SalChk sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:['AA_Test_New_Target1_30May.txt'],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     saveOrder: 1,",
						"     mapColumn(",
						"          NAME,",
						"          DEPARTMENT,",
						"          DESIGNATION,",
						"          SALARY,",
						"          Valid_Sal",
						"     ),",
						"     partitionBy('hash', 1)) ~> output1"
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/tp186029_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "rim_copy",
								"type": "DatasetReference"
							},
							"name": "source1"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "tp186029_RIM",
								"type": "DatasetReference"
							},
							"name": "outputstream"
						}
					],
					"transformations": [
						{
							"name": "GenericReason"
						}
					],
					"scriptLines": [
						"source(output(",
						"          {Flight#} as string,",
						"          Origin as string,",
						"          Dest as string,",
						"          FlightDate as string,",
						"          NoSalesReason as string,",
						"          TransmittingFlightAttd as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false) ~> source1",
						"source1 derive(derivedcolumn = locate(NoSalesReason,'Other')) ~> GenericReason",
						"GenericReason sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true) ~> outputstream"
					]
				}
			},
			"dependsOn": []
		}
	]
}